using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SixthImpulse.NameGenerator {

/// <summary>
/// A class that is used to generate a "unique" name
/// </summary>
/// <example>
///
/// // generate a single name using static method
/// string singleName = getNameStatic();
///
/// // generate 10 unique names using instantiated object with default options
/// SillyNameGenerator gen = new SillyNameGenerator();
/// string[] bunchOfNames = gen.getNames(10);
///
/// // generate a single name, modifying how the words are ordered, including a leading GUID
/// SillyNameGenerator gen = new SillyNameGenerator(new WordTypes[] { WordTypes.Guid, WordTypes.Verb, WordTypes.Noun}, "", CombineOptions.CapitalizeFirstLetter);
/// string nameWithGuid = gen.getName();
/// 
/// </example>
internal class SillyNameGenerator {

    #region Enums
    
    /// <summary>
    /// List of word types.  Used to define how the unique names are generated by combining the word types.
    /// </summary>
    internal enum WordTypes {
        Adjective,
        Verb,
        Noun,
        Guid
    }

    [Flags]
    internal enum CombineOptions {
        None = 0,

        CapitalizeFirstLetter = 1,
        UppercaseAll = 2,
        LowercaseAll = 4,
    }

    #endregion

    #region Data Members

    private static readonly WordTypes[]     DEFAULT_JOIN_MODEL          = new WordTypes[] { WordTypes.Verb, WordTypes.Adjective, WordTypes.Noun };
    private const string                    DEFAULT_JOIN_CHAR           = "-";
    private const CombineOptions            DEFAULT_OPTIONS             = CombineOptions.CapitalizeFirstLetter;

    // http://www.enchantedlearning.com/wordlist/adjectives.shtml
    private static readonly Dictionary<string, string[]> m_arrays = new Dictionary<string, string[]>() {
        { "adjectives", new string[] { "adorable", "acidic", "adept", "adorable", "affectionate", "aged", "aggravating", "aggressive", "agile", "alarming", "amazing", "angry", "aromatic", "awful", "awkward", "broken", "green", "pink", "purple", "red", "violet" } },
        { "verbs",      new string[] { "burning", "falling", "flying", "jumping", "running", "shimmering", "sparkling", "walking" } },
        { "nouns",      new string[] { "apple", "banana", "car", "cave", "city", "country", "crag", "fire", "flower", "house", "ice", "glacier", "gorilla", "lake", "lightning", "mango", "monkey", "mountain", "pineapple", "province", "river", "state", "stone", "stream", "tree", "vault", "vine", "volcano" } },
        { "guids",      null },
    };
    private static readonly Dictionary<WordTypes, string> m_wordArrayMap = new Dictionary<WordTypes, string>() {
        { WordTypes.Adjective, "adjectives" },
        { WordTypes.Verb,      "verbs" },
        { WordTypes.Noun,      "nouns" },
        { WordTypes.Guid,      "guids" },
    };   
    private WordTypes[]     m_joinModel         = null;
    private string          m_joiningChar       = "";
    private CombineOptions  m_options           = CombineOptions.None;

    private static readonly Random  m_random    = new Random();
    private static readonly SillyNameGenerator m_instance = new SillyNameGenerator();

    #endregion

    #region Constructor

    public SillyNameGenerator() 
        : this(DEFAULT_JOIN_MODEL, DEFAULT_JOIN_CHAR, DEFAULT_OPTIONS) { }

    public SillyNameGenerator(WordTypes[] joinModel, string joiningChar, CombineOptions options) {
        m_joinModel    = joinModel;
        m_joiningChar  = joiningChar;
        m_options      = options;

        return;
    }

    #endregion

    #region Properties

    internal WordTypes[] joinModel { 
        get { return m_joinModel; }
        set { m_joinModel = value; }
    }

    internal string joiningChar {
        get { return m_joiningChar; }
        set { m_joiningChar = value; }
    }

    internal CombineOptions options {
        get { return m_options; }
        set { m_options = value; }
    }

    #endregion

    #region Methods

    internal static string getNameStatic() {
        return m_instance.getName();
    }

    internal string getName() {
        List<string> rv = new List<string>();
        string word;

        for(int i = 0; i < m_joinModel.Length; i++) {
            if(m_joinModel[i] == WordTypes.Guid) {
                word = Guid.NewGuid().ToString("d");
            } else {
                string[] wordList = m_arrays[m_wordArrayMap[m_joinModel[i]]];
                word = wordList[m_random.Next(0, wordList.Length)];
            }
            word = _applyWordOptions(word, m_options);

            rv.Add(word);
        } // for

        return _applyCompleteOptions(string.Join(m_joiningChar, rv.ToArray()), options);
    }

    internal static string[] getNamesStatic(int numberOfNames) {
        return m_instance.getNames(numberOfNames);
    }

    internal string[] getNames(int numberOfNames) {
        List<string> rv = new List<string>();

        for(int i = 0; i < numberOfNames; i++) {
            rv.Add(getName());
        }

        return rv.ToArray();
    }

    #endregion 

    #region Private Procs

    /// <summary>
    /// Apply options that apply to single words
    /// </summary>
    /// <param name="word"></param>
    /// <param name="options"></param>
    /// <returns></returns>
    private string _applyWordOptions(string word, CombineOptions options) {
        
        word = word + "  "; // add the spaces so we're sure the string is non-blank for our string manip calls

        if((options & CombineOptions.CapitalizeFirstLetter) == CombineOptions.CapitalizeFirstLetter) {
            word = word .Substring(0, 1).ToUpper() + word.Substring(1).ToLower();
        } else if((options & CombineOptions.LowercaseAll) == CombineOptions.LowercaseAll) {
            word = word.ToLower();
        } else if((options & CombineOptions.UppercaseAll) == CombineOptions.UppercaseAll) {
            word = word.ToUpper();
        }

        return word.Trim();
    }

    /// <summary>
    /// Apply options that apply to final name
    /// </summary>
    /// <param name="word"></param>
    /// <param name="options"></param>
    /// <returns></returns>
    private string _applyCompleteOptions(string word, CombineOptions options) {
        
        return word.Trim();
    }

    #endregion
}
}